<h1 id="hypermedia-pipeline">Hypermedia Pipeline</h1>
<p>
  This project provides helper functions and default implementations for
  creating Hypermedia Processing Pipelines.
</p>
<p>
  It uses reducers and continuations to create a simple processing pipeline that
  can pre-and post-process HTML, JSON, and other hypermedia.
</p>
<h1 id="status">Status</h1>
<p>
  <a href="https://codecov.io/gh/adobe/hypermedia-pipeline"
    ><img
      src="https://img.shields.io/codecov/c/github/adobe/hypermedia-pipeline.svg"
      alt="codecov"/></a
  ><a href="https://circleci.com/gh/adobe/parcel-plugin-htl"
    ><img
      src="https://img.shields.io/circleci/project/github/adobe/hypermedia-pipeline.svg"
      alt="CircleCI"/></a
  ><a
    href="https://github.com/adobe/hypermedia-pipeline/blob/master/LICENSE.txt"
    ><img
      src="https://img.shields.io/github/license/adobe/hypermedia-pipeline.svg"
      alt="GitHub license"/></a
  ><a href="https://github.com/adobe/hypermedia-pipeline/issues"
    ><img
      src="https://img.shields.io/github/issues/adobe/hypermedia-pipeline.svg"
      alt="GitHub issues"/></a
  ><a href="https://www.npmjs.com/package/@adobe/hypermedia-pipeline"
    ><img
      src="https://img.shields.io/npm/dw/@adobe/hypermedia-pipeline.svg"
      alt="npm"/></a
  ><a href="https://greenkeeper.io/"
    ><img
      src="https://badges.greenkeeper.io/adobe/hypermedia-pipeline.svg"
      alt="Greenkeeper badge"
  /></a>
</p>
<h2 id="anatomy-of-a-pipeline">Anatomy of a Pipeline</h2>
<p>A pipeline consists of following main parts:</p>
<ul>
  <li>pre-processing functions</li>
  <li>the main response generating function</li>
  <li>an optional wrapper function</li>
  <li>post-processing functions</li>
</ul>
<p>
  Each step of the pipeline is processing a single payload object, that will
  slowly accumulate the <code>return</code> values of the functions above
  through <code>Object.assign</code>.
</p>
<p>See below for the anatomy of a payload.</p>
<p>
  Typically, there is one pipeline for each content type supported and pipeline
  are identified by file name, e.g.
</p>
<ul>
  <li>
    <code>html.pipe.js</code> – creates HTML documents with the
    <code>text/html</code> content-type
  </li>
  <li>
    <code>json.pipe.js</code> – creates JSON documents with the
    <code>application/json</code> content-type
  </li>
</ul>
<h3 id="building-a-pipeline">Building a Pipeline</h3>
<p>
  A pipeline builder can be created by creating a CommonJS module that exports a
  function <code>pipe</code> which accepts following arguments and returns a
  Pipeline function.
</p>
<ul>
  <li>
    <code>cont</code>: the main function that will be executed as a continuation
    of the pipeline
  </li>
  <li>
    <code>params</code>: a map of parameters that are interpreted at runtime
  </li>
  <li>
    <code>secrets</code>: a map of protected configuration parameters like API
    keys that should be handled with care. By convention, all keys in
    <code>secret</code> are in ALL_CAPS_SNAKE_CASE.
  </li>
  <li>
    <code>logger</code>: a
    <a href="https://www.github.com/winstonjs/winston">Winston</a> logger
  </li>
</ul>
<p>
  This project’s main entry provides a helper function for pipeline construction
  and a few helper functions, so that a basic pipeline can be constructed like
  this:
</p>
<pre><code class="language-javascript">// the pipeline itself const pipeline = require("@adobe/hypermedia-pipeline"); // helper functions and log const { adaptOWRequest, adaptOWResponse, log } = require('@adobe/hypermedia-pipeline/src/defaults/default.js'); module.exports.pipe = function(cont, params, secrets, logger = log) { logger.debug("Constructing Custom Pipeline"); return pipeline() .pre(adaptOWRequest) // optional: turns OpenWhisk-style arguments into a proper payload .once(cont) // required: execute the continuation function .post(adaptOWResponse) // optional: turns the Payload into an OpenWhisk-style response } </code></pre>
<p>
  In a typical pipeline, you will add additional processing steps as
  <code>.pre(require('some-module'))</code> or as
  <code>.post(require('some-module'))</code>.
</p>
<h3 id="the-main-function">The Main Function</h3>
<p>
  The main function is typically a pure function that converts the
  <code>request</code>, <code>context</code>, and
  <code>content</code> properties of the payload into a
  <code>response</code> object.
</p>
<p>
  In most scenarios, the main function is compiled from a template in a
  templating language like HTL, JST, or JSX.
</p>
<p>
  Typically, there is one template (and thus one main function) for each content
  variation of the file type. Content variations are identified by a selector
  (the piece of the file name before the file extension, e.g. in
  <code>example.navigation.html</code> the selector would be
  <code>navigation</code>). If no selector is provided, the template is the
  default template for the pipeline.
</p>
<p>Examples of possible template names include:</p>
<ul>
  <li>
    <code>html.jsx</code> (compiled to <code>html.js</code>) – default for the
    HTML pipeline
  </li>
  <li>
    <code>html.navigation.jst</code> (compiled to
    <code>html.navigation.js</code>) – renders the navigation
  </li>
  <li>
    <code>dropdown.json.js</code> (not compiled) – creates pure JSON output
  </li>
  <li>
    <code>dropdown.html.htl</code> (compiled to <code>dropdown.html.js</code>) –
    renders the dropdown component
  </li>
</ul>
<h3 id="optional-the-wrapper-function">(Optional) The Wrapper Function</h3>
<p>
  Sometimes it is neccessary to pre-process the payload in a template-specific
  fashion. This wrapper function (often called “Pre-JS” for brevity sake) allows
  the full transformation of the pipeline’s payload.
</p>
<p>
  Compared to the pipeline-specific pre-processing functions which handle the
  request, content, and response, the focus of the wrapper function is
  implementing business logic needed for the main template function. This allows
  for a clean separation between:
</p>
<ol>
  <li>
    presentation (in the main function, often expressed in declarative
    templates)
  </li>
  <li>
    business logic (in the wrapper function, often expressed in imperative code)
  </li>
  <li>
    content-type specific implementation (in the pipeline, expressed in
    functional code)
  </li>
</ol>
<p>A simple implementation of a wrapper function would look like this:</p>
<pre><code class="language-javascript">// All wrapper functions must export `pre` // The functions takes following arguments: // - `cont` (the continuation function, i.e. the main template function) // - `payload` (the payload of the pipeline) module.exports.pre = (cont, payload) =&gt; { const {request, content, context, response} = payload; // modifying the payload content before invoking the main function content.hello = 'World'; const modifiedpayload = {request, content, context, response}; // invoking the main function with the new payload. Capturing the response // payload for further modification const responsepayload = cont(modifiedpayload); // Adding a value to the payload response const modifiedresponse = modifiedpayload.response; modifiedresponse.hello = 'World'; return Object.assign(modifiedpayload, modifiedresponse); } </code></pre>
<h3 id="pre-processing-functions">Pre-Processing Functions</h3>
<p>Pre-Processing functions are meant to:</p>
<ul>
  <li>parse and process request parameters</li>
  <li>fetch and parse the requested content</li>
  <li>transform the requested content</li>
</ul>
<h3 id="post-processing-functions">Post-Processing Functions</h3>
<p>Post-Processing functions are meant to:</p>
<ul>
  <li>process and transform the response</li>
</ul>
<h2 id="anatomy-of-the-payload">Anatomy of the Payload</h2>
<p>Following main properties exist:</p>
<ul>
  <li><code>request</code></li>
  <li><code>content</code></li>
  <li><code>response</code></li>
  <li><code>context</code></li>
  <li><code>error</code></li>
</ul>
<h3 id="the-request-object">The <code>request</code> object</h3>
<ul>
  <li><code>params</code>: a map of request parameters</li>
  <li><code>headers</code>: a map of HTTP headers</li>
</ul>
<h3 id="the-content-object">The <code>content</code> object</h3>
<ul>
  <li><code>body</code>: the unparsed content body as a <code>string</code></li>
  <li>
    <code>mdast</code>: the parsed
    <a href="https://github.com/syntax-tree/mdast">Markdown AST</a>
  </li>
  <li>
    <code>meta</code>: a map metadata properties, including
    <ul>
      <li><code>title</code>: title of the document</li>
      <li><code>intro</code>: a plain-text introduction or description</li>
      <li><code>type</code>: the content type of the document</li>
    </ul>
  </li>
  <li><code>htast</code>: the HTML AST</li>
  <li><code>html</code>: a string of the content rendered as HTML</li>
  <li>
    <code>children</code>: an array of top-level elements of the HTML-rendered
    content
  </li>
</ul>
<h3 id="the-response-object">The <code>response</code> object</h3>
<ul>
  <li>
    <code>body</code>: the unparsed response body as a <code>string</code>
  </li>
  <li><code>headers</code>: a map of HTTP response headers</li>
  <li><code>status</code>: the HTTP status code</li>
</ul>
<h3 id="the-context-object">The <code>context</code> object</h3>
<p>TBD: used for stuff that is neither content, request, or response</p>
<h3 id="the-error-object">The <code>error</code> object</h3>
<p>
  This object is only set when there has been an error during pipeline
  processing. Any step in the pipeline may set the <code>error</code> object.
  Subsequent steps should simply skip any processing if they encounter an
  <code>error</code> object.
</p>
<p>
  Alternatively, steps can attempt to handle the <code>error</code> object, for
  instance by generating a formatted error message and leaving it in
  <code>response.body</code>.
</p>
<p>The only known property in <code>error</code> is</p>
<ul>
  <li><code>message</code>: the error message</li>
</ul>
